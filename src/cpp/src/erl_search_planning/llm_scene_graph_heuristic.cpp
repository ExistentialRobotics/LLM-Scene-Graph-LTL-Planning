#include "erl_search_planning/llm_scene_graph_heuristic.hpp"

namespace erl::search_planning {

    LLMSceneGraphHeuristic::LLMSceneGraphHeuristic(std::shared_ptr<Setting> setting, std::shared_ptr<env::EnvironmentLTLSceneGraph> env)
        : m_setting_(std::move(setting)),
          m_env_(std::move(env)) {
        ERL_ASSERTM(m_setting_ != nullptr, "setting is nullptr.");
        ERL_ASSERTM(m_env_ != nullptr, "env is nullptr.");

        uint32_t num_fsa_states = m_env_->m_fsa_->GetSetting()->num_states;
        for (auto &room_uuid: m_env_->m_scene_graph_->room_uuids) {
            m_heuristic_cache_[room_uuid].resize(num_fsa_states, std::numeric_limits<double>::infinity());
            for (uint32_t fsa_state = 0; fsa_state < num_fsa_states; ++fsa_state) {
                if (m_env_->m_fsa_->IsAcceptingState(fsa_state)) {
                    m_heuristic_cache_[room_uuid][fsa_state] = 0.0;
                    continue;
                }
                if (m_env_->m_fsa_->IsSinkState(fsa_state)) {
                    m_heuristic_cache_[room_uuid][fsa_state] = std::numeric_limits<double>::infinity();
                    continue;
                }

                auto &llm_path = m_setting_->llm_paths.at(room_uuid).at(fsa_state);
                if (llm_path.size() <= 1) {
                    m_heuristic_cache_[room_uuid][fsa_state] = 0.0;
                    continue;
                }

                double h = 0;
                std::size_t n = llm_path.size();
                for (std::size_t i = 1; i < n; ++i) {
                    switch (auto &[type, uuid1, uuid2] = llm_path[i]; type) {
                        case env::AtomicProposition::Type::kEnterRoom: {
                            auto room1 = m_env_->m_scene_graph_->GetNode<env::scene_graph::Room>(uuid1);
                            auto room2 = m_env_->m_scene_graph_->GetNode<env::scene_graph::Room>(uuid2);
                            h += (room1->location - room2->location).norm();
                            break;
                        }
                        case env::AtomicProposition::Type::kReachObject: {
                            auto room = m_env_->m_scene_graph_->GetNode<env::scene_graph::Room>(uuid1);
                            auto object = m_env_->m_scene_graph_->GetNode<env::scene_graph::Object>(uuid2);
                            h += (room->location - object->location).norm();
                            break;
                        }
                        default:
                            throw std::runtime_error("Unknown LLMWaypoint type.");
                    }
                }
                m_heuristic_cache_[room_uuid][fsa_state] = h;
            }
        }
    }

    double
    LLMSceneGraphHeuristic::operator()(const env::EnvironmentState &env_state) const {
        if (env_state.grid[0] == env::VirtualStateValue::kGoal) { return 0.0; }  // virtual goal

        const auto &scene_graph = m_env_->m_scene_graph_;
        const auto &fsa = m_env_->m_fsa_;
        auto &room_maps = m_env_->m_room_maps_;
        const int x = env_state.grid[0];
        const int y = env_state.grid[1];
        const int z = env_state.grid[2];
        const int q = env_state.grid[3];
        if (fsa->IsAcceptingState(q)) { return 0.0; }  // accepting state
        const int room_id = room_maps.at(z).at<int>(x, y);
        const int room_uuid = scene_graph->id_to_room.at(room_id)->uuid;
        const auto &llm_path = m_setting_->llm_paths.at(room_uuid).at(q);

        double h = m_heuristic_cache_.at(room_uuid)[q];
        const int next_uuid = llm_path[0].uuid2;
        switch (llm_path[0].type) {
            case env::AtomicProposition::Type::kEnterRoom: {
                const auto &room = scene_graph->GetNode<env::scene_graph::Room>(next_uuid);
                const double dx = room->location[0] - env_state.metric[0];
                const double dy = room->location[1] - env_state.metric[1];
                const double dz = room->location[2] - env_state.metric[2];
                h += std::sqrt(dx * dx + dy * dy + dz * dz);
                break;
            }
            case env::AtomicProposition::Type::kReachObject: {
                const auto &object = scene_graph->GetNode<env::scene_graph::Object>(next_uuid);
                const double dx = object->location[0] - env_state.metric[0];
                const double dy = object->location[1] - env_state.metric[1];
                const double dz = object->location[2] - env_state.metric[2];
                h += std::sqrt(dx * dx + dy * dy + dz * dz);
                break;
            }
            default:
                throw std::runtime_error("Unknown LLMWaypoint type.");
        }

        return h;

        // // use the precomputed cost maps and path maps to get a more accurate heuristic, but paths generated by LLM
        // // sometimes omit some rooms, causing instructions like move(uuid1, uuid2) while room of uuid1 and room of
        // // uuid2 are not adjacent. This makes it impossible to use the precomputed cost maps and path maps. Unless we
        // // use a backup process to fix such instructions. But this makes the LLM heuristics pointless.
        // auto &scene_graph = m_env_->m_scene_graph_;
        // auto &room_maps = m_env_->m_room_maps_;
        // // auto &cat_maps = m_env_->m_cat_maps_;
        // // auto &label_maps = m_env_->m_label_maps_;
        // auto &up_stairs_cost_maps = m_env_->m_up_stairs_cost_maps_;
        // // auto &up_stairs_path_maps = m_env_->m_up_stairs_path_maps_;
        // auto &down_stairs_cost_maps = m_env_->m_down_stairs_cost_maps_;
        // // auto &down_stairs_path_maps = m_env_->m_down_stairs_path_maps_;
        // auto &room_cost_maps = m_env_->m_room_cost_maps_;
        // auto &object_cost_maps = m_env_->m_object_cost_maps_;
        //
        // int x = env_state.grid[0];
        // int y = env_state.grid[1];
        // int z = env_state.grid[2];
        // int q = env_state.grid[3];
        // if (fsa->IsAcceptingState(q)) { return 0.0; }  // accepting state
        // int room_id = room_maps.at(z).at<int>(x, y);
        // ERL_DEBUG("room_id = %d, room_uuid = %d, fsa_state = %d", room_id, scene_graph->id_to_room.at(room_id)->uuid, q);
        // auto floor = scene_graph->floors.at(z);
        //
        // auto &cached_h = const_cast<double &>(m_heuristic_cache_.at(room_id).at(q));
        // if (cached_h < std::numeric_limits<double>::infinity()) { return cached_h; }
        //
        // auto &llm_path = m_setting_->llm_paths.at(scene_graph->id_to_room.at(room_id)->uuid).at(env_state.grid[3]);
        // // play llm_path
        // double cost = 0.0;
        // for (auto &waypoint: llm_path) {
        //     switch (waypoint.type) {
        //         case env::AtomicProposition::Type::kEnterRoom: {
        //             auto room1 = scene_graph->GetNode<erl::env::scene_graph::Room>(waypoint.uuid1);
        //             auto room2 = scene_graph->GetNode<erl::env::scene_graph::Room>(waypoint.uuid2);
        //             if (room1->id == floor->up_stairs_id || room1->id == floor->down_stairs_id) {
        //                 // just go down/up stairs
        //                 ERL_ASSERTM(
        //                     room_id == room2->id,
        //                     "llm path is wrong, expecting room(id %d, uuid %d), got room(id %d, uuid %d).",
        //                     room2->id,
        //                     room2->uuid,
        //                     room_id,
        //                     scene_graph->id_to_room.at(room_id)->uuid);
        //             } else if (room2->id == floor->down_stairs_id) {  // go down stairs
        //                 cost += down_stairs_cost_maps.at(z)(x, y);
        //                 z -= 1;
        //                 floor = scene_graph->floors.at(z);
        //                 x = floor->up_stairs_portal.value()[0];
        //                 y = floor->up_stairs_portal.value()[1];
        //                 // q = int(fsa->GetNextState(q, label_maps.at(z)(x, y)));
        //                 room_id = room_maps.at(z).at<int>(x, y);
        //             } else if (room2->id == floor->up_stairs_id) {  // go up stairs
        //                 cost += up_stairs_cost_maps.at(z)(x, y);
        //                 z += 1;
        //                 floor = scene_graph->floors.at(z);
        //                 x = floor->down_stairs_portal.value()[0];
        //                 y = floor->down_stairs_portal.value()[1];
        //                 // q = int(fsa->GetNextState(q, label_maps.at(z)(x, y)));
        //                 room_id = room_maps.at(z).at<int>(x, y);
        //             } else if (room1->parent_id == room2->parent_id) {  // on the same floor
        //                 auto &room_cost_map = room_cost_maps.at(room1->id).at(room2->id);
        //                 int r = x - room_cost_map.grid_min_x;
        //                 int c = y - room_cost_map.grid_min_y;
        //                 cost += room_cost_map.cost_map(r, c);
        //                 auto &arrived_at = room_cost_map.path_map(r, c).back();
        //                 x = arrived_at[0];
        //                 y = arrived_at[1];
        //                 // z remains unchanged
        //                 // q = int(fsa->GetNextState(q, label_maps.at(z)(x, y)));
        //                 room_id = room_maps.at(z).at<int>(x, y);
        //                 ERL_ASSERTM(
        //                     room_id == room2->id,
        //                     "llm path is wrong, expecting room(id %d, uuid %d), got room(id %d, uuid %d).",
        //                     room2->id,
        //                     room2->uuid,
        //                     room_id,
        //                     scene_graph->id_to_room.at(room_id)->uuid);
        //                 // floor remains unchanged
        //             }
        //             break;
        //         }
        //         case env::AtomicProposition::Type::kReachObject: {
        //             auto room = scene_graph->GetNode<erl::env::scene_graph::Room>(waypoint.uuid1);
        //             auto object = scene_graph->GetNode<erl::env::scene_graph::Object>(waypoint.uuid2);
        //             ERL_ASSERTM(
        //                 object->parent_id == room->id,
        //                 "llm path is wrong, expecting object(id %d, uuid %d) in room(id %d, uuid %d), got room(id %d, uuid %d).",
        //                 object->id,
        //                 object->uuid,
        //                 room->id,
        //                 room->uuid,
        //                 object->parent_id,
        //                 scene_graph->id_to_room.at(object->parent_id)->uuid);
        //             auto &local_cost_map = object_cost_maps.at(object->id);
        //             int r = x - local_cost_map.grid_min_x;
        //             int c = y - local_cost_map.grid_min_y;
        //             cost += local_cost_map.cost_map(r, c);
        //             auto &arrived_at = local_cost_map.path_map(r, c).back();
        //             x = arrived_at[0];
        //             y = arrived_at[1];
        //             // z remains unchanged
        //             // q = int(fsa->GetNextState(q, label_maps.at(z)(x, y)));
        //             // room_id remains unchanged
        //             // floor remains unchanged
        //             break;
        //         }
        //         default:
        //             throw std::runtime_error("Unknown LLMWaypoint type.");
        //     }
        // }
        // cached_h = cost;
        // return cost;
    }

}  // namespace erl::search_planning
